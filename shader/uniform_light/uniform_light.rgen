#version 460
#extension GL_GOOGLE_include_directive : enable
#include "common.glsl"
#include "random.glsl"

layout(location = 0) rayPayloadEXT HitPayload payload;

int sampleLightUniform(inout uint seed)
{
    if(pushConstants.numLights == 1) return 0;
    return int(rand(seed) * float(pushConstants.numLights - 1.0));
}

void main()
{
    // Calc seed
    uvec2 s = pcg2d(uvec2(gl_LaunchIDEXT.xy * (pushConstants.frame + 1)));
    uint seed = s.x + s.y;

    vec3 position = imageLoad(positionImage, ivec2(gl_LaunchIDEXT.xy)).rgb;
    vec3 normal = imageLoad(normalImage, ivec2(gl_LaunchIDEXT.xy)).rgb;
    vec3 diffuse = imageLoad(diffuseImage, ivec2(gl_LaunchIDEXT.xy)).rgb;
    vec3 emission = imageLoad(emissionImage, ivec2(gl_LaunchIDEXT.xy)).rgb;
    uint instanceIndex = imageLoad(instanceIndexImage, ivec2(gl_LaunchIDEXT.xy)).x;

    if(length(emission) > 0.1) {
        imageStore(outputImage, ivec2(gl_LaunchIDEXT.xy), vec4(emission, 1));
        return;
    }

    // Get buffer addresses
    BufferAddress address = addresses.address[instanceIndex];
    SphereLights sphereLights = SphereLights(address.sphereLights);

    // Sample light
    int lightIndex = sampleLightUniform(seed);
    SphereLight sphereLight = sphereLights.s[lightIndex];
    vec3 hitToLight = sphereLight.position - position;
    float dist = length(hitToLight) - sphereLight.radius;
    vec3 dir = normalize(hitToLight);

    // trace shadow ray
    payload.shadowed = true;
    traceRayEXT(
        topLevelAS,
        gl_RayFlagsTerminateOnFirstHitEXT | 
        gl_RayFlagsSkipClosestHitShaderEXT,
        0xff, // cullMask
        0,    // sbtRecordOffset
        0,    // sbtRecordStride
        0,    // missIndex
        position, 0.001,
        dir, dist,
        0     // payloadLocation
    );

    // hit light
    vec3 radiance = vec3(0.0);
    if(!payload.shadowed){
        float invDistPow2 = 1.0 / (dist * dist);
        float cosTheta = max(0.0, dot(normalize(dir), normal));
        float pdf = 1.0 / pushConstants.numLights;
        vec3 brdf = diffuse / M_PI;
        radiance = sphereLight.intensity * brdf * invDistPow2 * cosTheta / pdf;
    }
    vec3 color = emission + radiance;
    
    imageStore(outputImage, ivec2(gl_LaunchIDEXT.xy), vec4(color, 1));
}
