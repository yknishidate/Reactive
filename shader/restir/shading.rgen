#version 460
#extension GL_GOOGLE_include_directive : enable
#include "common.glsl"
#include "random.glsl"

layout(location = 0) rayPayloadEXT HitPayload payload;

// TODO: rename
vec3 sampleSphereLight(in vec2 randVal, in vec3 dir)
{
    vec3 normal = -normalize(dir);
    vec3 tangent;
    vec3 bitangent;
    createCoordinateSystem(normal, tangent, bitangent);

    vec3 sampleDir = sampleHemisphere(randVal.x, randVal.y);
    return sampleDir.x * tangent + sampleDir.y * bitangent + sampleDir.z * normal;
}

void main()
{
    // Calc seed
    uvec2 s = pcg2d(uvec2(gl_LaunchIDEXT.xy * (pushConstants.frame + 1)));
    payload.seed = s.x + s.y;

    vec3 pos = imageLoad(posImage, ivec2(gl_LaunchIDEXT.xy)).rgb;
    vec3 normal = imageLoad(normalImage, ivec2(gl_LaunchIDEXT.xy)).rgb;
    vec3 diffuse = imageLoad(diffuseImage, ivec2(gl_LaunchIDEXT.xy)).rgb;
    vec3 emission = imageLoad(emissionImage, ivec2(gl_LaunchIDEXT.xy)).rgb;
    uint lightIndex = imageLoad(reservoirSampleImage, ivec2(gl_LaunchIDEXT.xy)).x;
    float weight = imageLoad(reservoirWeightImage, ivec2(gl_LaunchIDEXT.xy)).x;
    uvec4 geometryIndex = imageLoad(indexImage, ivec2(gl_LaunchIDEXT.xy));
    uint instanceIndex = geometryIndex.x;
    uint primitiveIndex = geometryIndex.y;

    // Get buffer addresses
    BufferAddress address = addresses.address[instanceIndex];
    Vertices vertices = Vertices(address.vertices);
    Indices indices = Indices(address.indices);
    Objects objects = Objects(address.objects);
    SphereLights sphereLights = SphereLights(address.sphereLights);

    SphereLight sphereLight = sphereLights.s[lightIndex];

    // Sample point on light
    // vec3 dir = sphereLight.position - pos;
    // float dist = length(dir);
    vec3 dir = sphereLight.position - pos;
    vec3 lightNormal = sampleSphereLight(vec2(rand(payload.seed), rand(payload.seed)), dir);
    vec3 point = sphereLight.position + sphereLight.radius * lightNormal;
    dir = point - pos;
    float dist = length(dir);

    // trace shadow ray
    payload.done = false;
    traceRayEXT(
        topLevelAS,
        gl_RayFlagsOpaqueEXT,
        // gl_RayFlagsTerminateOnFirstHitEXT | 
        // gl_RayFlagsSkipClosestHitShaderEXT,
        0xff, // cullMask
        0,    // sbtRecordOffset
        0,    // sbtRecordStride
        0,    // missIndex
        pos, 0.001,
        normalize(dir), dist - 0.001,
        0     // payloadLocation
    );

    vec3 contribute = vec3(0.0);
    if(payload.done){
        float invDistPow2 = 1.0 / (dist * dist);
        float cosTheta = max(0.0, dot(normalize(dir), normal));
        float cosThetaLight = max(0.0, dot(normalize(-dir), lightNormal));
        // float cosThetaLight = 1.0;
        float pdf = 1.0 / pushConstants.numLights / (2.0 * M_PI * sphereLight.radius * sphereLight.radius);
        vec3 brdf = diffuse / M_PI;
        contribute = weight * sphereLight.intensity * brdf * invDistPow2 * cosTheta * cosThetaLight / pdf;
    }
    imageStore(outputImage, ivec2(gl_LaunchIDEXT.xy), vec4(contribute, 1));

    // payload.color += contribute * reservoirWeight;
    // payload.emission = emission;
    // payload.position = pos;
    // payload.normal = normal;
    // payload.brdf = brdf;

    // // Calc seed
    // uvec2 s = pcg2d(uvec2(gl_LaunchIDEXT.xy * (pushConstants.frame + 1)));
    // payload.seed = s.x + s.y;
    
    // // Calc ray
    // const vec2 screenPos = vec2(gl_LaunchIDEXT.xy) + vec2(rand(payload.seed), rand(payload.seed));
    // const vec2 inUV = screenPos / vec2(gl_LaunchSizeEXT.xy);
    // vec2 d = inUV * 2.0 - 1.0;

    // vec4 origin    = pushConstants.invView * vec4(0, 0, 0, 1);
    // vec4 target    = pushConstants.invProj * vec4(d.x, d.y, 1, 1) ;
    // vec4 direction = pushConstants.invView * vec4(normalize(target.xyz), 0) ;
    // traceRayEXT(
    //     topLevelAS,
    //     gl_RayFlagsOpaqueEXT,
    //     0xff, // cullMask
    //     0,    // sbtRecordOffset
    //     0,    // sbtRecordStride
    //     0,    // missIndex
    //     origin.xyz,
    //     0.001,
    //     direction.xyz,
    //     10000.0,
    //     0     // payloadLocation
    // );
    //if(payload.skip){
    //    depth--;
    //    origin = vec4(payload.position, 1.0);
    //    payload.skip = false;
    //    continue;
    //}
}
